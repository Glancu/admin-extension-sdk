"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[210],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=d(n),u=o,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8698:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return h}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=["components"],s={},l="How it works",d={unversionedId:"guide/internals/how-it-works",id:"guide/internals/how-it-works",isDocsHomePage:!1,title:"How it works",description:"The Admin Extension SDK provides wrapper methods for a better development experience. It abstracts and hides the more",source:"@site/docs/guide/internals/how-it-works.md",sourceDirName:"guide/internals",slug:"/guide/internals/how-it-works",permalink:"/admin-extension-sdk/docs/guide/internals/how-it-works",tags:[],version:"current",frontMatter:{},sidebar:"Guide",previous:{title:"Window",permalink:"/admin-extension-sdk/docs/guide/api-reference/window"}},p=[{value:"Admin communication",id:"admin-communication",children:[{value:"Example workflow",id:"example-workflow",children:[],level:3}],level:2},{value:"Sending methods",id:"sending-methods",children:[],level:2}],c={toc:p};function h(e){var t=e.components,s=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-it-works"},"How it works"),(0,i.kt)("p",null,"The Admin Extension SDK provides wrapper methods for a better development experience. It abstracts and hides the more\ncomplex logic behind a simple API. This makes it easier for app and plugin developer to create their solutions and focus\nmore on business details instead of technical details."),(0,i.kt)("h2",{id:"admin-communication"},"Admin communication"),(0,i.kt)("p",null,"Technically the apps and plugins are communicating to the administration via the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage"},"postMessage API"),". It is a secure communication channel between different windows. In most cases it will be used to communicate\nfrom a iFrame to the main window and the other way around."),(0,i.kt)("p",null,"The Extension SDK works in the same way but it uses a hybrid approach. Every method is callable within a iFrame and also\nfrom the same window. This allows apps (in iFrames) and plugins (in the same window) to use the same API."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"postMessage communication",src:n(3607).Z})),(0,i.kt)("p",null,"Normally the postMessage API is very limited and not very friendly to use. You can send string values from one window to\nanother. This isn't very handy to use for smooth development. To provide a smoother experience we wrote some helper methods to\nmake working with the postMessage API a breeze."),(0,i.kt)("p",null,"The helper methods can be found in the ",(0,i.kt)("inlineCode",{parentName:"p"},"channel")," file. It has different methods for easier communication. The most important ones are ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"handle"),". They are responsible for sending and handling the data."),(0,i.kt)("p",null,"Do give you an better understanding how it works we go trough an example."),(0,i.kt)("h3",{id:"example-workflow"},"Example workflow"),(0,i.kt)("p",null,"Let's imagine that a app or plugin calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"context.getLanguage")," method from the Extension SDK:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// from app/plugin\nconst language = await sw.context.getLanguage();\n")),(0,i.kt)("p",null,"What happens in the background? The method is a wrapper for the ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," method in the ",(0,i.kt)("inlineCode",{parentName:"p"},"channel"),". When you use it it will call ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," with a predefined type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// from app/plugin\nsend('contextLanguage', {});\n")),(0,i.kt)("p",null,"Each message has an unique type. They are hidden for plugin and app developers and are only responsible for the underlying handling. With the unique type we know in the admin what type of request it is and what response it expects."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," method is doing now some magic in the background. It creates a data object with following properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  _type: 'contextLanguage',\n  _data: {},\n  _callbackId: 'aRand0mGeneratedUniqueId'\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"_type")," property is for the recognition of the request type. The ",(0,i.kt)("inlineCode",{parentName:"p"},"_data")," property is custom data which will be added by the app or plugin. E.g. the title, message and more for a notification. And the ",(0,i.kt)("inlineCode",{parentName:"p"},"_callbackId")," is needed so that the administration can send the data back with the ID and the sender can recognize it and use the data."),(0,i.kt)("p",null,"This object will be sent as a stringified JSON object to the administration window via the postMessage API."),(0,i.kt)("p",null,"Now let's have a look at what needs to happen on the administration side."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// at administration\nhandle('contextLanguage', () => {\n    return {\n        languageId: Shopware.Context.api.languageId,\n        systemLanguageId: Shopware.Context.api.systemLanguageId,\n    };\n});\n")),(0,i.kt)("p",null,"It uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," method which is also a helper method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"channel"),". You see that the type matches the sender type. And in the second argument it provides a method which returns the data."),(0,i.kt)("p",null,"This method reacts to every ",(0,i.kt)("inlineCode",{parentName:"p"},"contextLanguage")," request and send the data values back to the source of the request. It also creates a object with meta information which are needed for the original ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," window:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  _type: 'contextLanguage',\n  _response: { languageId: '1a2b3c...', systemLanguageId: '9f8g7h...', },\n  _callbackId: 'aRand0mGeneratedUniqueId'\n}\n")),(0,i.kt)("p",null,"The source who will send the request is adding a new event listener before it sends the message. This event listener listen to all incoming messages and if any of these messages is matching the type and the callback ID of the sent message then it will handle the data."),(0,i.kt)("p",null,"In our case it will get back an stringified object with the language information. These will parsed and returned to the first method call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// from app/plugin\nconst language = await sw.context.getLanguage();\n\n// language = { languageId: '1a2b3c...', systemLanguageId: '9f8g7h...', }\n")),(0,i.kt)("p",null,"And this was it! The app or plugin has got the data from the administration. It looks like a simple call. But it does a lot in the background."),(0,i.kt)("h2",{id:"sending-methods"},"Sending methods"),(0,i.kt)("p",null,"In normal cases you can't add methods to JSON objects which will get stringified. In our case we think it would makes the life of many developers easier if they can also use their methods in the calls."),(0,i.kt)("p",null,"To handle these edge-case we are converting the methods to information objects like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  __type__: '__function__',\n  id: 'theUniqueFunctionId' // will be generated uniquely\n}\n")),(0,i.kt)("p",null,"The method will be saved in a ",(0,i.kt)("inlineCode",{parentName:"p"},"methodRegistry")," where the unique ID can be used as an identifier."),(0,i.kt)("p",null,"The receiver of the object convert this object back to a method which would trigger the original method. This can't be done directly because we do not have direct access to the method. To solve this problem we send a special postMessage call to the original source. This call contains all arguments of the called method and the unique ID of the method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"send('__function__', {\n  args: args,\n  id: id,\n})\n")),(0,i.kt)("p",null,"The sender gets the message and execute the method with the matching ID with the given arguments. The return value will be then sent back to the converted method in the receiver."),(0,i.kt)("p",null,"This complex logic is also abstracted. To use it: just add methods to\nthe data. It will be converted and handled automatically."))}h.isMDXComponent=!0},3607:function(e,t,n){t.Z=n.p+"assets/images/post-message-communication-5f4077de47c2eab8350eb1a00f63ffd0.png"}}]);